<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DSPatch: DSPatch Design Specification</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="heartbeat.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DSPatch
   &#160;<span id="projectnumber">v.4.00</span>
   </div>
   <div id="projectbrief">C++ Flow-Based Programming Framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">DSPatch Design Specification </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>1. The Circuit Concept: </h2>
<p>A circuit is comprised of a collection of interconnected components. Each component has 2 signal buses, on one end of the component there are inputs (the "input bus"), and on the other end there are outputs (the "output bus"). Components within the circuit are connected to each other via wires. Each wire carries a signal from one component's output to another component's input. A circuit can also comprise of interconnected circuits - in this case a circuit acts as a component within another circuit.</p>
<hr/>
<h2>2. The DSPatch Circuit System: </h2>
<p><b>2.1 Structure:</b></p>
<p>The nouns above are the classes we require in order to model our circuit in code. Each component will contain an array of input wires. Each wire contains references to the source component, the source output, and the destination input. The signal bus class will contain an array of signals, and lastly, the Circuit class will be derived from Component and will contain an array of internal components.</p>
<p><b>2.2 Behavior:</b></p>
<p><b>2.2.1 Component:</b></p>
<p>The Component class will have a Tick() method responsible for acquiring its next set of inputs from its input wires and populating the component's input bus. To insure that these inputs are up-to-date, the dependent component first calls all of its input components' Tick() methods - hence recursively called in all components going backward through the circuit. The acquired input bus is then passed into a virtual method: Process_() - it is the responsibility of the (derived) component creator to implement this virtual method. The Process_() method has 2 input arguments: the input bus and the output bus. This method's purpose is to pull its required inputs out of the input bus, process these inputs, then populate the output bus with the results. These resultant outputs in the output bus are then acquired by dependent components via their Tick() methods.</p>
<p>The Component class will also have a Reset() method. For optimization as well as to avoid feedback deadlocks, a component needs to be aware of whether or not it has already ticked during a circuit traversal so that if asked to Tick() again, it can ignore the call. The Reset() method informs the component that the last circuit traversal has completed and hence may execute the next Tick() request.</p>
<p><b>2.2.2 Circuit:</b></p>
<p>In order to satisfy the statement above ("circuit acts as a component"), the Circuit class is derived from the Component class. This means that the Circuit class has both Tick() and Process_() methods. The Tick() method will execute as normal, acquiring inputs for the circuit to process. This allows us to expose the IO we require for internal components via the circuit's input and output buses. Circuit IO-to-component wires, and component-to-component wires, will be publicly routable via Circuit class methods. The Circuit class' virtual Process_() method is implemented as such:</p>
<ul>
<li>Inputs from the circuit's input bus are moved to their respective internal component input buses.</li>
<li>All internal components are Tick()ed.</li>
<li>All internal components are Reset()ed.</li>
<li>The circuit output bus is populated with the respective internal component outputs.</li>
</ul>
<p>All actions in respect to the circuit and the components within the circuit will be made available via public methods in the Circuit class. The circuit object user will be able to add/remove components, connect/disconnect wires, and set/get circuit IO count.</p>
<p><b>2.2.3 Signal:</b></p>
<p>When it comes to transferring signals between components we require the same level of abstraction for the data being moved around:</p>
<p>The base Component class needs to supply its child class with any number of inputs and outputs via the virtual Process_() method. These inputs and outputs may also need to be of different types. This requires a generic way of containing variables of different types in a single collection - the signal bus.</p>
<p>The signal class will hold a variable that can be dynamically typed at run-time, which we'll call "run-type". The run-type and signal classes make use of template methods to allow object users to set and get the contained variable as any type they wish. The run-type (and hence, a signal) has the ability to change type at any point during program execution - this can be useful for inputs that can accept a number of different types of data (E.g. Varying sample size in an audio buffer: array of byte / int / float)</p>
<p>From the Process_() method, a derived component can get and set the signals it requires of the provided signal buses via public methods. As the component creator is responsible for configuring the component's IO buses, the types held within those buses can be assumed, and hence, read and written to accordingly. Built-in typecasting and error checking prevents critical run-time errors from occurring when signal types are mismatched.</p>
<hr/>
<h2>3. Parallel Circuit Processing: </h2>
<p>The multi-threading aspect of DSPatch is designed to allow the library user the ability to specify the number of threads in which he/she requires the circuit to process, rather than the thread count growing as the system does. So for example, an application running on a quad core CPU could be limited to 4 threads in order to allow each core to handle just one thread.</p>
<p><b>3.1 The Circuit Thread:</b></p>
<p>Circuit Threads are threads that traverse entire circuits. The circuit runs through its array of components, calling each components' process method in a single thread (the Circuit Thread) loop. As each component is done processing, it hands over control to the next waiting Circuit Thread. Therefore, if you had 5 components in a process chain, and 5 Circuit Threads, at any point in time you could have one thread per component processing in parallel.</p>
<p>With this in place, you now also have the option to select 0 Circuit Threads. In this state, the circuit's Tick() and Reset() methods will block the calling thread while all components in the circuit are processed, whereas with circuit threads enabled, the calling thread will block only if all Circuit Threads are busy.</p>
<p><b>3.2 The Component Thread:</b></p>
<p>The Component Thread simply ticks a single component over and over. As the Circuit class inherits from Component, we can use its Component Thread to "auto-tick" the circuit in order to free up the main application thread for control. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Oct 8 2018 23:03:10 for DSPatch by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>

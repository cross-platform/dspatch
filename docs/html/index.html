<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DSPatch: The Refreshingly Simple C++ Dataflow Framework</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="heartbeat.png"/></td>
  <td id="projectalign">
   <div id="projectname">DSPatch<span id="projectnumber">&#160;v.11.3.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="doc-content">
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">The Refreshingly Simple C++ Dataflow Framework </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="intro_sec"></a>
Introduction</h1>
<p>DSPatch, pronounced "dispatch", is a powerful C++ dataflow framework. DSPatch is not limited to any particular domain or data type, from reactive programming to stream processing, DSPatch's generic, object-oriented API allows you to create virtually any graph processing system imaginable.</p>
<p>DSPatch is designed around the concept of a "circuit" that contains "components" interconnected via "wires" that transfer "signals" to and from I/O "buses".</p>
<p>The two most important classes to consider are <a class="el" href="class_d_s_patch_1_1_component.html" title="Abstract base class for DSPatch components.">DSPatch::Component</a> and <a class="el" href="class_d_s_patch_1_1_circuit.html" title="Workspace for adding and routing components.">DSPatch::Circuit</a>. In order to route data to and from components they must be added to a circuit, where they can be wired together.</p>
<p>The DSPatch engine takes care of data transfers between interconnected components. When data is ready for a component to process, a callback: "Process_()" is executed in that component. For a component to form part of a DSPatch circuit, designers simply have to derive their component from the <a class="el" href="class_d_s_patch_1_1_component.html" title="Abstract base class for DSPatch components.">DSPatch::Component</a> base class, configure the component's IO buses, and implement the virtual Process_() callback method.</p>
<p><br  />
 </p>
<h1><a class="anchor" id="features_sec"></a>
Features</h1>
<ul>
<li><b>Automatic branch synchronization</b> - The result of data diverging across parallel branches is guaranteed to arrive synchronized at a converging point.</li>
<li><b>Component plugins</b> - Package components into plugins to be dynamically loaded into other host applications.</li>
<li><b>Cross-platform</b> - DSPatch is built and tested daily on Linux, Mac and Windows. <a href="https://www.youtube.com/watch?v=u3A9x9bpbdo"><b>Here</b></a> we see DSPatch running flawlessly on a BeagleBone!</li>
<li><b>Easy-to-use header-only API</b> - DSPatch is modelled around real-world circuit entities and concepts, making code more readable and easy to understand.</li>
<li><b>High performance multi-buffering</b> - Utilize parallel multi-buffering via Circuit::SetBufferCount() to maximize dataflow efficiency in stream processing circuits.</li>
<li><b>High performance multi-threading</b> - Utilize parallel multi-threading via Circuit::SetThreadCount() to maximize dataflow efficiency across parallel branches.</li>
<li><b>Feedback loops</b> - Create true closed-circuit systems by feeding component outputs back into previous component inputs (supported in multi-buffered circuits but not multi-threaded).</li>
<li><b>Optimised signal transfers</b> - Wherever possible, data between components is transferred via move rather than copy.</li>
<li><b>Run-time adaptive signal types</b> - Component inputs can accept values of run-time varying types allowing you to create more flexible, multi-purpose component processes.</li>
<li><b>Run-time circuit wiring</b> - Connect and disconnect wires on the fly whilst maintaining steady dataflow through the system.</li>
</ul>
<p><br  />
 </p>
<h1><a class="anchor" id="start_sec"></a>
Getting Started</h1>
<ol type="1">
<li>Download DSPatch:<ul>
<li><a href="https://github.com/cross-platform/dspatch"><b>GitHub repository</b></a></li>
<li><a href="https://github.com/cross-platform/dspatch-template"><b>DSPatch project template</b></a></li>
</ul>
</li>
<li><a class="el" href="#tutorial_sec">Read the tutorials</a></li>
<li><a href="https://github.com/cross-platform/dspatchables/tree/master/Components"><b>Browse some example components</b></a></li>
<li><a href="annotated.html"><b>Refer to the API docs</b></a></li>
</ol>
<p><br  />
 </p>
<h1><a class="anchor" id="tutorial_sec"></a>
Tutorials</h1>
<h2><a class="anchor" id="create_component"></a>
1. Creating a component</h2>
<p>In order to create a new component, we must derive our component class from the <a class="el" href="class_d_s_patch_1_1_component.html" title="Abstract base class for DSPatch components.">DSPatch::Component</a> base class, configure component IO, and implement the inherited virtual "Process_()" method.</p>
<p>Lets take a look at how we would go about creating a very simple boolean logic "AND" component. This component will accept 2 boolean input values and output the result of: input 1 &amp;&amp; input 2.</p>
<p>We begin by deriving our new "AndBool" component from Component:</p>
<div class="fragment"><div class="line"><span class="comment">//  1. Derive AndBool class from Component</span></div>
<div class="line"><span class="comment">//  ======================================</span></div>
<div class="line"><span class="keyword">class </span>AndBool final : <span class="keyword">public</span> <a class="code hl_class" href="class_d_s_patch_1_1_component.html">DSPatch::Component</a></div>
<div class="line">{</div>
<div class="ttc" id="aclass_d_s_patch_1_1_component_html"><div class="ttname"><a href="class_d_s_patch_1_1_component.html">DSPatch::Component</a></div><div class="ttdoc">Abstract base class for DSPatch components.</div><div class="ttdef"><b>Definition</b> <a href="_component_8h_source.html#l00064">Component.h:65</a></div></div>
</div><!-- fragment --><p>The next step is to configure our component's input and output buses. This is achieved by calling the base protected methods: SetInputCount_() and SetOutputCount_() respectively from our component's constructor. In our component's case, we require 2 inputs and 1 output, therefore our constructor code will look like this:</p>
<div class="fragment"><div class="line"><span class="keyword">public</span>:</div>
<div class="line"><span class="comment">//  2. Configure component IO buses</span></div>
<div class="line"><span class="comment">//  ===============================</span></div>
<div class="line">    AndBool()</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// add 2 inputs</span></div>
<div class="line">        SetInputCount_( 2 );</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// add 1 output</span></div>
<div class="line">        SetOutputCount_( 1 );</div>
<div class="line">    }</div>
</div><!-- fragment --><p>Lastly, our component must implement the virtual Process_() method. This is where our component does its work. The Process_() method provides us with 2 arguments: the input bus and the output bus. It is our duty as the component designer to pull the inputs we require out of the input bus, process them accordingly, then populate the output bus with the results.</p>
<p>Our component's process method will look something like this:</p>
<div class="fragment"><div class="line"><span class="keyword">protected</span>:</div>
<div class="line"><span class="comment">//  3. Implement virtual Process_() method</span></div>
<div class="line"><span class="comment">//  ======================================</span></div>
<div class="line">    <span class="keywordtype">void</span> Process_( <a class="code hl_class" href="class_d_s_patch_1_1_signal_bus.html">DSPatch::SignalBus</a>&amp; inputs, <a class="code hl_class" href="class_d_s_patch_1_1_signal_bus.html">DSPatch::SignalBus</a>&amp; outputs )<span class="keyword"> override</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="comment">// create some local pointers to hold our input values</span></div>
<div class="line">        <span class="keyword">auto</span> bool1 = inputs.GetValue&lt;<span class="keywordtype">bool</span>&gt;( 0 );</div>
<div class="line">        <span class="keyword">auto</span> bool2 = inputs.GetValue&lt;<span class="keywordtype">bool</span>&gt;( 1 );</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// check first that our component has received valid inputs</span></div>
<div class="line">        <span class="keywordflow">if</span>( bool1 &amp;&amp; bool2 )</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// set the output as the result of bool1 AND bool2</span></div>
<div class="line">            outputs.SetValue( 0, *bool1 &amp;&amp; *bool2 );</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="ttc" id="aclass_d_s_patch_1_1_signal_bus_html"><div class="ttname"><a href="class_d_s_patch_1_1_signal_bus.html">DSPatch::SignalBus</a></div><div class="ttdoc">Signal container.</div><div class="ttdef"><b>Definition</b> <a href="_signal_bus_8h_source.html#l00052">SignalBus.h:53</a></div></div>
</div><!-- fragment --><p>Our component is now ready to form part of a DSPatch circuit. Next we'll look at how we can add our component to a circuit and route it to and from other components.</p>
<p><br  />
 </p>
<h2><a class="anchor" id="use_component"></a>
2. Building a circuit</h2>
<p>In order for us to get any real use out of our components, we need them to interact with each other. This is where the <a class="el" href="class_d_s_patch_1_1_circuit.html" title="Workspace for adding and routing components.">DSPatch::Circuit</a> class comes in. A circuit is a workspace for adding and routing components. In this section we will have a look at how to create a simple DSPatch application that generates random boolean pairs, performs a logic AND on each pair, then prints the result to the screen.</p>
<p>First we must include the DSPatch header and any other headers that contain components we wish to use in our application:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;components.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;DSPatch.h&gt;</span></div>
</div><!-- fragment --><p>Next, we must instantiate our circuit object and all component objects needed for our circuit. Lets say we had 2 other components included with "AndBool" (from the first tutorial): "GenBool" (generates a random boolean value then outputs the result) and "PrintBool" (receives a boolean value and outputs it to the console):</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line"><span class="comment">//  1. Create a circuit where we can route our components</span></div>
<div class="line"><span class="comment">//  =====================================================</span></div>
<div class="line">    <span class="keyword">auto</span> circuit = std::make_shared&lt;DSPatch::Circuit&gt;();</div>
<div class="line"> </div>
<div class="line"><span class="comment">//  2. Create instances of the components needed for our circuit</span></div>
<div class="line"><span class="comment">//  ============================================================</span></div>
<div class="line">    <span class="keyword">auto</span> genBool1 = std::make_shared&lt;GenBool&gt;();</div>
<div class="line">    <span class="keyword">auto</span> genBool2 = std::make_shared&lt;GenBool&gt;();</div>
<div class="line">    <span class="keyword">auto</span> andBool = std::make_shared&lt;AndBool&gt;();</div>
<div class="line">    <span class="keyword">auto</span> printBool = std::make_shared&lt;PrintBool&gt;();</div>
</div><!-- fragment --><p>Now that we have a circuit and some components, lets add all of our components to the circuit:</p>
<div class="fragment"><div class="line"><span class="comment">//  3. Add component instances to circuit</span></div>
<div class="line"><span class="comment">//  =====================================</span></div>
<div class="line">    circuit-&gt;AddComponent( genBool1 );</div>
<div class="line">    circuit-&gt;AddComponent( genBool2 );</div>
<div class="line">    circuit-&gt;AddComponent( andBool );</div>
<div class="line">    circuit-&gt;AddComponent( printBool );</div>
</div><!-- fragment --><p>We are now ready to begin wiring the circuit:</p>
<div class="fragment"><div class="line"><span class="comment">//  4. Wire up the components inside the circuit</span></div>
<div class="line"><span class="comment">//  ============================================</span></div>
<div class="line">    circuit-&gt;ConnectOutToIn( genBool1, 0, andBool, 0 );</div>
<div class="line">    circuit-&gt;ConnectOutToIn( genBool2, 0, andBool, 1 );</div>
<div class="line">    circuit-&gt;ConnectOutToIn( andBool, 0, printBool, 0 );</div>
</div><!-- fragment --><p>The code above results in the following wiring configuration: </p><pre class="fragment">  __________            _________
 |          |          |         |
 | genBool1 |-0 ===&gt; 0-|         |           ___________
 |__________|          |         |          |           |
  __________           | andBool |-0 ===&gt; 0-| printBool |
 |          |          |         |          |___________|
 | genBool2 |-0 ===&gt; 1-|         |
 |__________|          |_________|</pre><p>Lastly, in order for our circuit to do any work it must be ticked. This is performed by repeatedly calling the circuit's Tick() method. This method can be called manually in a loop, or alternatively, by calling StartAutoTick(), a seperate thread will spawn, automatically calling Tick() continuously.</p>
<p>Furthermore, to boost performance in stream processing circuits like this one, multi-buffering can be enabled via the SetBufferCount() method:</p>
<p><b>NOTE:</b> If none of the parallel branches in your circuit are time-consuming (⪆10μs), multi-buffering (or even zero buffering) will almost always outperform multi-threading (via SetThreadCount()). The contention overhead caused by multiple threads processing a single tick must be made negligible by time-consuming parallel components for any performance improvement to be seen.</p>
<div class="fragment"><div class="line"><span class="comment">//  5. Tick the circuit</span></div>
<div class="line"><span class="comment">//  ===================</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Circuit tick method 1: Manual</span></div>
<div class="line">    <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i = 0; i &lt; 10; ++i )</div>
<div class="line">    {</div>
<div class="line">        circuit-&gt;Tick();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Circuit tick method 2: Automatic</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Press any key to begin circuit auto-tick.&quot;</span>;</div>
<div class="line">    getchar();</div>
<div class="line">    circuit-&gt;StartAutoTick();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Increase circuit buffer count for higher performance</span></div>
<div class="line">    getchar();</div>
<div class="line">    circuit-&gt;SetBufferCount( 4 );</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Press any key to quit</span></div>
<div class="line">    getchar();</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>That's it! Enjoy using DSPatch!</p>
<p>(<b>NOTE:</b> The source code for the above tutorials can be found under the "tutorial" folder in the <a href="https://github.com/cross-platform/dspatch"><b>DSPatch root directory</b></a>). </p>
</div></div><!-- PageDoc -->
<a href="doxygen_crawl.html"/>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0
</small></address>
</div><!-- doc-content -->
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DSPatch: The C++ Flow-Based Programming Framework</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="heartbeat.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DSPatch
   &#160;<span id="projectnumber">v.4.00</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">The C++ Flow-Based Programming Framework </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="intro_sec"></a>
Introduction</h1>
<p>DSPatch, pronounced "dispatch", is a powerful C++ flow-based programming framework. DSPatch is not limited to any particular domain or data type, its generic, object-oriented API allows you to create almost any system imaginable, from simple logic circuits to high performance audio process chains.</p>
<p>DSPatch is designed around the concept of a "circuit" that contains "components" interconnected via "wires" that transfer "signals" to and from component I/O "buses". For more detail on how DSPatch works internally, check out the <a href="spec_page.html"><b>DSPatch Design Specification</b></a>.</p>
<p>The two most important classes to consider are <a class="el" href="class_d_s_patch_1_1_component.html" title="Abstract base class for DSPatch components. ">DSPatch::Component</a> and <a class="el" href="class_d_s_patch_1_1_circuit.html" title="Workspace for adding and routing components. ">DSPatch::Circuit</a>. In order to route data to and from components they must be added to a circuit, where they can be wired together.</p>
<p>The DSPatch engine takes care of data transfer between interconnected components. When data is ready for a component to process, a callback: "Process_()" is executed in that component. For a component to form part of a DSPatch circuit, designers simply have to derive their component from the <a class="el" href="class_d_s_patch_1_1_component.html" title="Abstract base class for DSPatch components. ">DSPatch::Component</a> base class, configure the component's IO buses, and implement the virtual Process_() callback method.</p>
<p><br />
 </p>
<h1><a class="anchor" id="features_sec"></a>
Features</h1>
<ul>
<li><b>Automatic branch synchronization</b> - The result of data diverging across parallel branches is guaranteed to arrive synchronized at a converging point.</li>
<li><b>Component plugins</b> - Package components into plugins to be dynamically loaded into DSPatch host applications.</li>
<li><b>Dynamic thread count adjustment</b> - Specify at run-time, the number of threads in which you require a circuit to process.</li>
<li><b>Easy-to-use object-oriented API</b> - DSPatch is modeled around real-world circuit entities and concepts, making code more readable and easy to understand.</li>
<li><b>Feedback loops</b> - Create true closed-circuit systems by feeding resultant signals back into previous component inputs.</li>
<li><b>High performance parallel processing</b> - Circuits use advanced multi-threaded scheduling to maximize data flow efficiency.</li>
<li><b>Integrated circuits</b> - Build circuits within circuits to encapsulate complex component networks into single circuit components.</li>
<li><b>Optimised signal transfers</b> - Wherever possible, data between components is transfered via move rather than copy.</li>
<li><b>Run-time circuit wiring</b> - Connect and disconnect wires on the fly whilst maintaining steady data flow through the system.</li>
<li><b>Run-time adaptive signal types</b> - Component inputs can accept values of run-time varying types allowing you to create more flexible, multi-purpose component processes.</li>
</ul>
<p><br />
 </p>
<h1><a class="anchor" id="start_sec"></a>
Getting Started</h1>
<ol type="1">
<li>Download DSPatch:<ul>
<li>Binaries (Linux):<ul>
<li><a href="https://github.com/MarcusTomlinson/DSPatch/archive/build/master/linux-gcc.zip"><b>GCC</b></a> - <a href="https://github.com/MarcusTomlinson/DSPatch/archive/build/master/linux-clang.zip"><b>Clang</b></a></li>
</ul>
</li>
<li>Binaries (MacOS):<ul>
<li><a href="https://github.com/MarcusTomlinson/DSPatch/archive/build/master/osx-gcc.zip"><b>GCC</b></a> - <a href="https://github.com/MarcusTomlinson/DSPatch/archive/build/master/osx-clang.zip"><b>Clang</b></a></li>
</ul>
</li>
<li>Binaries (Windows):<ul>
<li><a href="https://github.com/MarcusTomlinson/DSPatch/archive/build/master/win-mingw-x86.zip"><b>MinGW</b></a> - <a href="https://github.com/MarcusTomlinson/DSPatch/archive/build/master/win-msvc-x86.zip"><b>MSVC</b></a></li>
</ul>
</li>
<li>Source Code:<ul>
<li><a href="https://github.com/MarcusTomlinson/DSPatch"><b>GitHub</b></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="el" href="index.html#tutorial_sec">Read the tutorials</a></li>
<li><a href="https://github.com/MarcusTomlinson/DSPatchables"><b>Browse some example components</b></a></li>
<li><a href="annotated.html"><b>Refer to the API docs</b></a></li>
</ol>
<p><br />
 </p>
<h1><a class="anchor" id="tutorial_sec"></a>
Tutorials</h1>
<h2><a class="anchor" id="create_component"></a>
1. Creating a component</h2>
<p>In order to create a new component, we must derive our component class from the <a class="el" href="class_d_s_patch_1_1_component.html" title="Abstract base class for DSPatch components. ">DSPatch::Component</a> base class, configure component IO, and implement the inherited virtual "Process_()" method.</p>
<p>Lets take a look at how we would go about creating a very simple boolean logic "AND" component. This component will accept 2 boolean input values and output the result of: input 1 &amp;&amp; input 2.</p>
<p>We begin by deriving our new "And" component from Component:</p>
<div class="fragment"><div class="line"><span class="comment">// 1. Derive And class from Component</span></div><div class="line"><span class="comment">// ==================================</span></div><div class="line"><span class="keyword">class </span>And final : <span class="keyword">public</span> Component</div><div class="line">{</div></div><!-- fragment --><p>The next step is to configure our component's input and output buses. This is achieved by calling the base protected methods: SetInputCount_() and SetOutputCount_() respectively from our component's constructor. In our component's case, we require 2 inputs and 1 output, therefore our constructor code will look like this:</p>
<div class="fragment"><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">// 2. Configure component IO buses</span></div><div class="line">    <span class="comment">// ===============================</span></div><div class="line">    And()</div><div class="line">    {</div><div class="line">        <span class="comment">// add 2 inputs</span></div><div class="line">        SetInputCount_( 2 );</div><div class="line"></div><div class="line">        <span class="comment">// add 1 output</span></div><div class="line">        SetOutputCount_( 1 );</div><div class="line">    }</div></div><!-- fragment --><p>Lastly, our component must implement the virtual Process_() method. This is where our component does it's work. The Process_() method provides us with 2 arguments: the input bus and the output bus. It is our duty as the component designer to pull the inputs we require out of the input bus, process them accordingly, then populate the output bus with the results.</p>
<p>Our component's process method will look something like this:</p>
<div class="fragment"><div class="line"><span class="keyword">protected</span>:</div><div class="line">    <span class="comment">// 3. Implement virtual Process_() method</span></div><div class="line">    <span class="comment">// ======================================</span></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> Process_( SignalBus <span class="keyword">const</span>&amp; inputs, SignalBus&amp; outputs )<span class="keyword"> override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">        <span class="comment">// create some local pointers to hold our input values</span></div><div class="line">        <span class="keyword">auto</span> bool1 = inputs.GetValue&lt;<span class="keywordtype">bool</span>&gt;( 0 );</div><div class="line">        <span class="keyword">auto</span> bool2 = inputs.GetValue&lt;<span class="keywordtype">bool</span>&gt;( 1 );</div><div class="line"></div><div class="line">        <span class="comment">// check first that our component has received valid inputs</span></div><div class="line">        <span class="keywordflow">if</span>( bool1 &amp;&amp; bool2 )</div><div class="line">        {</div><div class="line">            <span class="comment">// set the output as the result of bool1 AND bool2</span></div><div class="line">            outputs.SetValue( 0, *bool1 &amp;&amp; *bool2 );</div><div class="line">        }</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p>Our component is now ready to form part of a DSPatch circuit. Next we'll look at how we can add our component to a circuit and route it to and from other components.</p>
<p><br />
 </p>
<h2><a class="anchor" id="use_component"></a>
2. Building a circuit</h2>
<p>In order for us to get any real use out of our components, we need them to interact with each other. This is where the <a class="el" href="class_d_s_patch_1_1_circuit.html" title="Workspace for adding and routing components. ">DSPatch::Circuit</a> class comes in. A circuit is a workspace for adding and routing components. In this section we will have a look at how to create a simple DSPatch application that generates random boolean pairs, performs a logic AND on each pair, then prints the result to the screen.</p>
<p>First we must include the DSPatch header and any other headers that contain components we wish to use in our application:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;DSPatch.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;components.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespace_d_s_patch.html">DSPatch</a>;</div></div><!-- fragment --><p>Next, we must instantiate our circuit object and all component objects needed for our circuit. Lets say we had 2 other components included with "And" (from the first tutorial): "RandBool" (generates a random boolean value then outputs the result) and "PrintBool" (receives a boolean value and outputs it to the console):</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">    <span class="comment">// 1. Create a circuit where we can route our components</span></div><div class="line">    <span class="comment">// =====================================================</span></div><div class="line">    <span class="keyword">auto</span> circuit = std::make_shared&lt;Circuit&gt;();</div><div class="line"></div><div class="line">    <span class="comment">// 2. Create instances of the components needed for our circuit</span></div><div class="line">    <span class="comment">// ============================================================</span></div><div class="line">    <span class="keyword">auto</span> randBoolGen1 = std::make_shared&lt;RandBool&gt;();</div><div class="line">    <span class="keyword">auto</span> randBoolGen2 = std::make_shared&lt;RandBool&gt;();</div><div class="line">    <span class="keyword">auto</span> logicAnd = std::make_shared&lt;And&gt;();</div><div class="line">    <span class="keyword">auto</span> boolPrinter = std::make_shared&lt;PrintBool&gt;();</div></div><!-- fragment --><p>Now that we have a circuit and some components, lets add all of our components to the circuit:</p>
<div class="fragment"><div class="line"><span class="comment">// 3. Add component instances to circuit</span></div><div class="line"><span class="comment">// =====================================</span></div><div class="line">circuit-&gt;AddComponent( randBoolGen1 );</div><div class="line">circuit-&gt;AddComponent( randBoolGen2 );</div><div class="line">circuit-&gt;AddComponent( logicAnd );</div><div class="line">circuit-&gt;AddComponent( boolPrinter );</div></div><!-- fragment --><p>We are now ready to begin wiring the circuit:</p>
<div class="fragment"><div class="line"><span class="comment">// 4. Wire up the components inside the circuit</span></div><div class="line"><span class="comment">// ============================================</span></div><div class="line">circuit-&gt;ConnectOutToIn( randBoolGen1, 0, logicAnd, 0 );</div><div class="line">circuit-&gt;ConnectOutToIn( randBoolGen2, 0, logicAnd, 1 );</div><div class="line">circuit-&gt;ConnectOutToIn( logicAnd, 0, boolPrinter, 0 );</div></div><!-- fragment --><p>The code above results in the following wiring configuration: </p><div class="fragment"><div class="line">                               ___________</div><div class="line">[<span class="stringliteral">&quot;Bool Generator 1&quot;</span>] 0 ---&gt; 0 |           |</div><div class="line">                              |<span class="stringliteral">&quot;Logic AND&quot;</span>| 0 ---&gt; 0 [<span class="stringliteral">&quot;Bool Printer&quot;</span>]</div><div class="line">[<span class="stringliteral">&quot;Bool Generator 2&quot;</span>] 0 ---&gt; 1 |___________|</div><div class="line">_</div></div><!-- fragment --><p>Lastly, in order for our circuit to do any work it must be ticked over. This is performed by repeatedly calling the circuit's Tick() and Reset() methods. These methods can be called manually in a loop from the main application thread, or alternatively, by calling StartAutoTick(), a seperate thread will spawn, automatically calling Tick() and Reset() continuously.</p>
<p>A circuit's thread count can be adjusted at runtime, allowing us to increase / decrease the number of threads use by the circuit as required during execution:</p>
<div class="fragment"><div class="line">    <span class="comment">// 5. Tick the circuit</span></div><div class="line">    <span class="comment">// ===================</span></div><div class="line"></div><div class="line">    <span class="comment">// Circuit tick method 1: Manual</span></div><div class="line">    <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i = 0; i &lt; 10; i++ )</div><div class="line">    {</div><div class="line">        circuit-&gt;Tick();</div><div class="line">        circuit-&gt;Reset();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Circuit tick method 2: Automatic</span></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Press any key to begin circuit auto-tick.&quot;</span>;</div><div class="line">    getchar();</div><div class="line">    circuit-&gt;StartAutoTick();</div><div class="line"></div><div class="line">    <span class="comment">// Increase Circuit Thread count for higher performance</span></div><div class="line">    getchar();</div><div class="line">    circuit-&gt;SetThreadCount( 4 );</div><div class="line"></div><div class="line">    <span class="comment">// Press any key to quit</span></div><div class="line">    getchar();</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>That's it! Enjoy using DSPatch!</p>
<p>(<b>NOTE:</b> The source code for the above tutorials can be found under the "tutorial" folder in the DSPatch root directory).</p>
<p><br />
 </p>
<h1><a class="anchor" id="changelog"></a>
Changelog</h1>
<h2><a class="anchor" id="v400"></a>
v.4.00 (07 October 2018)</h2>
<ul>
<li>Major C++14 refactor.</li>
<li>Moved audio-related example components to the <a href="https://github.com/MarcusTomlinson/DSPatchables">DSPatchables</a> project.</li>
<li>Removed overly complex Parameter concept.</li>
<li>Removed the horrid "Global Circuit", along with DSPatch::Finalize().</li>
<li>Greatly simplified component plugins.</li>
<li>Optimised signal transfer by moving rather than copying where possible.</li>
<li>Added CI and unit tests.</li>
</ul>
<h2><a class="anchor" id="v300"></a>
v.3.00 (07 April 2015)</h2>
<ul>
<li>Reference parameters by index for better performance.</li>
<li>Cleaned up code formatting and class interfaces.</li>
<li>DisconnectComponent fixed to also remove outgoing wires.</li>
<li>ResumeAutoTick() resumes only once called for every PauseAutoTick().</li>
<li>Updates to support <a href="https://github.com/MarcusTomlinson/DSPatcher">DSPatcher</a>.</li>
</ul>
<h2><a class="anchor" id="v270"></a>
v.2.70 (21 December 2014)</h2>
<ul>
<li>Added support for DspComponent plugins (DspPlugin + DspPluginLoader).</li>
<li>Fixed build and install scripts.</li>
</ul>
<h2><a class="anchor" id="v262"></a>
v.2.62 (18 August 2014)</h2>
<ul>
<li>Added alternative Get* methods returning const pointers.</li>
<li>Increased build warning level and fixed all issues.</li>
<li>Uninitialised variable fix for DspParameter.</li>
<li>Fixed GetInput/Output/ParameterName() empty string return bug.</li>
</ul>
<h2><a class="anchor" id="v261"></a>
v.2.61 (16 June 2014)</h2>
<ul>
<li>Introduced component parameters (DspParameter).</li>
<li>Added DspComponent user callback mechanism.</li>
<li>Improved const-correctness and code style.</li>
<li>Added ability to remove single IO pins.</li>
</ul>
<h2><a class="anchor" id="v260"></a>
v.2.60 (19 January 2014)</h2>
<ul>
<li>Replaced project files with more flexible CMakeLists.</li>
<li>DspWaveStreamer fix (don't assume standard type sizes).</li>
<li>Reduced size of distributable.</li>
</ul>
<h2><a class="anchor" id="v251"></a>
v.2.51 (13 September 2013)</h2>
<ul>
<li>Fixed Unix thread detach error.</li>
<li>Improved overall encapsulation.</li>
<li>Replaced "Clear" with "Remove" for I/O removal.</li>
</ul>
<h2><a class="anchor" id="v250"></a>
v.2.50 (14 July 2013)</h2>
<ul>
<li>Reduced size of distributable.</li>
<li>Removed closed source dependency from example project.</li>
<li>Added Linux makefiles.</li>
</ul>
<h2><a class="anchor" id="v243"></a>
v.2.43 (30 June 2013)</h2>
<ul>
<li>Simplified platform selection macros.</li>
</ul>
<h2><a class="anchor" id="v242"></a>
v.2.42 (24 June 2013)</h2>
<ul>
<li>Added vs2008 and vs2010 versions of dspdemo.</li>
<li>Code style and performance improvements.</li>
</ul>
<h2><a class="anchor" id="v241"></a>
v.2.41 (07 February 2013)</h2>
<ul>
<li>Fixed VS2010 dspdemo linker errors.</li>
</ul>
<h2><a class="anchor" id="v240"></a>
v.2.40 (04 February 2013)</h2>
<ul>
<li>Optimized DspRunType.</li>
<li>Added Stop() method to DspThread.</li>
<li>Reduced pointer dereferencing and temporaries.</li>
</ul>
<h2><a class="anchor" id="v233"></a>
v.2.33 (01 February 2013)</h2>
<ul>
<li>Signal reading / writing optimized.</li>
<li>Code cleaned up and re-formatted.</li>
</ul>
<h2><a class="anchor" id="v232"></a>
v.2.32 (24 January 2013)</h2>
<ul>
<li>Reduced component thread mutex locking.</li>
<li>Fixed DspCircuit AddInput() run-time error.</li>
<li>Documentation updates.</li>
</ul>
<h2><a class="anchor" id="v231"></a>
v.2.31 (19 December 2012)</h2>
<ul>
<li>Improved synchronization in AddComponent().</li>
<li>Component routing upgraded to template methods.</li>
</ul>
<h2><a class="anchor" id="v230"></a>
v.2.30 (15 December 2012)</h2>
<ul>
<li>Circuit routing simplified.</li>
<li>Completed "circuit-less" component processing.</li>
<li>Component names now optional.</li>
<li>DspCircuit no longer deletes external memory.</li>
<li>Optimized circuit-in-circuit processing.</li>
</ul>
<h2><a class="anchor" id="v22"></a>
v.2.2 (08 December 2012)</h2>
<ul>
<li>A component can no longer exist in multiple circuits.</li>
<li>Added coding tutorials</li>
<li>Cleaned up project directory structure.</li>
<li>Comments and documentation updates.</li>
<li>Resolved component / circuit thread count clash.</li>
</ul>
<h2><a class="anchor" id="v21"></a>
v.2.1 (06 November 2012)</h2>
<ul>
<li>Removed DspSafePointer class.</li>
<li>Greatly improved overall performance.</li>
<li>Added commenting for doxygen.</li>
</ul>
<h2><a class="anchor" id="v20"></a>
v.2.0 (02 November 2012)</h2>
<ul>
<li>Re-licensed DSPatch to LGPL.</li>
<li>Added support for non-threaded platforms.</li>
<li>Circuit routing upgraded to more flexible template methods.</li>
</ul>
<h2><a class="anchor" id="v12"></a>
v.1.2 (20 October 2012)</h2>
<ul>
<li>Ported to Unix-based OS's.</li>
<li>Completed circuit-in-circuit logic.</li>
</ul>
<h2><a class="anchor" id="v11"></a>
v.1.1 (17 October 2012)</h2>
<ul>
<li>Various bug fixes.</li>
<li>Added 2 more components to the dspdemo project.</li>
<li>Optimized threaded circuit processing.</li>
<li>AddComponent() updated to accept pre-constructed DspComponents.</li>
</ul>
<h2><a class="anchor" id="v10"></a>
v.1.0 (14 October 2012)</h2>
<ul>
<li>Extracted routing engine behind "Crosstalk" to form: "DSPatch". </li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Oct 9 2018 08:52:51 for DSPatch by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
